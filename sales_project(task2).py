# -*- coding: utf-8 -*-
"""Sales_Project(Task2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YWP3UNDr0YLrOBwpRWbeqFsv1ZV8orpJ

**Sales Prediction Project Overview**

project involves analyzing a dataset that tracks the advertising expenditures across three media channels (TV, Radio, and Newspaper) and their corresponding sales outcomes over a specified period. The dataset includes the following key columns:

* TV: The amount spent on television advertisements (numeric).
* Radio: The amount spent on radio advertisements (numeric).
* Newspaper: The amount spent on newspaper advertisements (numeric).
* Sales: The total sales achieved during the given period (numeric).

Project Objective:

Objective of project is to predict total sales based on the advertising spend across the three platforms. By employing machine learning techniques such as Linear Regression,aim to:

*  Analyze the relationship between advertising budgets on different media channels and their impact on sales.
* Build a predictive model that can accurately forecast future sales based on advertising expenditures, thereby enabling businesses to optimize their advertising strategy and budget allocation.

**Step 1: Install Required Libraries**
"""

!pip install dash

# Data Manipulation Libraries
import pandas as pd
import numpy as np

# Data Visualization Libraries
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px  # Plotly for interactive visualizations

# Machine Learning Libraries
from sklearn.model_selection import train_test_split, cross_val_score  # For train-test split and cross-validation
from sklearn.linear_model import LinearRegression, Lasso
from sklearn.ensemble import RandomForestRegressor  # Random Forest model
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import PolynomialFeatures

# Dash Web Application Libraries
import dash
from dash import dcc, html
from dash.dependencies import Input, Output

# Additional Libraries for data processing
from sklearn.preprocessing import PolynomialFeatures, StandardScaler

"""**Step 2: Load and Explore the Dataset**"""

# Step 1: Load the dataset
df = pd.read_csv('/content/drive/MyDrive/Advertising.csv')  # Replace 'your_dataset.csv' with the actual dataset file path

# Step 2: Data Exploration
# Display the first few rows of the dataset to understand its structure
print("First few rows of the dataset:")
print(df.head())

# Display dataset information (includes data types and non-null counts)
print("\nDataset Information:")
print(df.info())

# Display the shape of the dataset (number of rows and columns)
print("\nShape of the dataset:")
print(df.shape)

# Display summary statistics of the dataset
print("\nSummary statistics:")
print(df.describe().T)

# Check for missing values in the dataset
print("\nMissing values:")
print(df.isnull().sum())

# Check for duplicate rows in the dataset
print("\nChecking for duplicate rows:")
duplicates = df.duplicated().sum()
print(f'Total duplicate rows: {duplicates}')

# Display data types of each column
print("\nData Types:")
print(df.dtypes)

"""**Step 3: Data Preprocessing**"""

# Remove the "Unnamed: 0" column from the DataFrame
df = df.drop(columns=["Unnamed: 0"])

# This will remove the unwanted column (usually an index or a placeholder) and update the DataFrame 'df'

"""**Step 4: Exploratory Data Analysis (EDA)**

**1. Correlation Heatmap**
"""

# Set the style of the plots
sns.set(style="whitegrid")

# Correlation matrix
corr = df.corr()

# Plot the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5, vmin=-1, vmax=1)
plt.title('Correlation Heatmap', fontsize=16)
plt.show()

"""**2. Pairplot**"""

# Pairplot to visualize pairwise relationships
sns.pairplot(df, hue="Sales", palette="viridis", plot_kws={'alpha': 0.6}, height=2.5)
plt.suptitle('Pairplot of Features with Sales Color-Coding', fontsize=16)
plt.show()

"""**3. Distribution Plots**"""

# Set up a figure with multiple subplots
fig, axs = plt.subplots(2, 2, figsize=(14, 10))

# KDE plot for TV
sns.kdeplot(df['TV'], shade=True, color='b', ax=axs[0, 0], fill=True)
axs[0, 0].set_title('Distribution of TV Spend')

# KDE plot for Radio
sns.kdeplot(df['Radio'], shade=True, color='r', ax=axs[0, 1], fill=True)
axs[0, 1].set_title('Distribution of Radio Spend')

# KDE plot for Newspaper
sns.kdeplot(df['Newspaper'], shade=True, color='g', ax=axs[1, 0], fill=True)
axs[1, 0].set_title('Distribution of Newspaper Spend')

# KDE plot for Sales
sns.kdeplot(df['Sales'], shade=True, color='purple', ax=axs[1, 1], fill=True)
axs[1, 1].set_title('Distribution of Sales')

plt.tight_layout()
plt.show()

"""**4. Scatter Plots with Linear Fit**"""

# Scatter plot with a linear fit for TV vs Sales
plt.figure(figsize=(8, 6))
sns.regplot(x='TV', y='Sales', data=df, scatter_kws={'color':'orange'}, line_kws={'color':'darkred'})
plt.title('TV Spend vs Sales', fontsize=16)
plt.xlabel('TV Spend', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.show()

# Scatter plot with a linear fit for Radio vs Sales
plt.figure(figsize=(8, 6))
sns.regplot(x='Radio', y='Sales', data=df, scatter_kws={'color':'blue'}, line_kws={'color':'darkblue'})
plt.title('Radio Spend vs Sales', fontsize=16)
plt.xlabel('Radio Spend', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.show()

# Scatter plot with a linear fit for Newspaper vs Sales
plt.figure(figsize=(8, 6))
sns.regplot(x='Newspaper', y='Sales', data=df, scatter_kws={'color':'green'}, line_kws={'color':'darkgreen'})
plt.title('Newspaper Spend vs Sales', fontsize=16)
plt.xlabel('Newspaper Spend', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.show()

"""**5. Box Plots to detect Outliers**"""

# Set up a figure with multiple subplots
fig, axs = plt.subplots(2, 3, figsize=(18, 10))

# Boxplot for TV spend
sns.boxplot(x=df['TV'], ax=axs[0, 0], color='lightblue')
axs[0, 0].set_title('TV Spend Boxplot')

# Boxplot for Radio spend
sns.boxplot(x=df['Radio'], ax=axs[0, 1], color='lightcoral')
axs[0, 1].set_title('Radio Spend Boxplot')

# Boxplot for Newspaper spend
sns.boxplot(x=df['Newspaper'], ax=axs[0, 2], color='lightgreen')
axs[0, 2].set_title('Newspaper Spend Boxplot')

# Boxplot for Sales with a valid color (e.g., lightviolet)
sns.boxplot(x=df['Sales'], ax=axs[1, 0], color='lavender')
axs[1, 0].set_title('Sales Boxplot')

# Hide the empty subplot (since we only have 4 features)
axs[1, 1].axis('off')
axs[1, 2].axis('off')

plt.tight_layout()
plt.show()

"""**6. Sales vs Multiple Features with Color Coding**"""

# Visualize relationship between TV and Sales with color coding by Sales
plt.figure(figsize=(8, 6))
sns.scatterplot(x='TV', y='Sales', data=df, hue='Sales', palette='coolwarm', size='Sales', sizes=(50, 300), alpha=0.7)
plt.title('TV Spend vs Sales with Color Coding', fontsize=16)
plt.xlabel('TV Spend', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.legend(title='Sales', loc='upper left')
plt.show()

# Visualize relationship between Radio and Sales with color coding by Sales
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Radio', y='Sales', data=df, hue='Sales', palette='coolwarm', size='Sales', sizes=(50, 300), alpha=0.7)
plt.title('Radio Spend vs Sales with Color Coding', fontsize=16)
plt.xlabel('Radio Spend', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.legend(title='Sales', loc='upper left')
plt.show()

# Visualize relationship between Newspaper and Sales with color coding by Sales
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Newspaper', y='Sales', data=df, hue='Sales', palette='coolwarm', size='Sales', sizes=(50, 300), alpha=0.7)
plt.title('Newspaper Spend vs Sales with Color Coding', fontsize=16)
plt.xlabel('Newspaper Spend', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.legend(title='Sales', loc='upper left')
plt.show()

"""**7. Visualizing the Data Distribution Histograms**"""

# Set up a figure with multiple subplots for histograms
fig, axs = plt.subplots(2, 3, figsize=(18, 10))

# Histogram for TV spend with a new color
sns.histplot(df['TV'], bins=20, ax=axs[0, 0], kde=True, color='royalblue')
axs[0, 0].set_title('TV Spend Histogram')

# Histogram for Radio spend with a new color
sns.histplot(df['Radio'], bins=20, ax=axs[0, 1], kde=True, color='tomato')
axs[0, 1].set_title('Radio Spend Histogram')

# Histogram for Newspaper spend with a new color
sns.histplot(df['Newspaper'], bins=20, ax=axs[0, 2], kde=True, color='mediumseagreen')
axs[0, 2].set_title('Newspaper Spend Histogram')

# Histogram for Sales with a new color
sns.histplot(df['Sales'], bins=20, ax=axs[1, 0], kde=True, color='orchid')
axs[1, 0].set_title('Sales Histogram')

# Hide the empty subplot (since we only have 4 features)
axs[1, 1].axis('off')
axs[1, 2].axis('off')

plt.tight_layout()
plt.show()

"""**Step 5: Handle Outliers**"""

# Select only numeric columns dynamically
df= df.select_dtypes(include='number')

# Calculate IQR for each numeric column
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1

# Define the lower and upper bounds for each feature
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Handle outliers: cap values beyond the upper and lower bounds (Winsorizing)
for col in df.columns:
    df[col] = np.where(df[col] > upper_bound[col], upper_bound[col], df[col])
    df[col] = np.where(df[col] < lower_bound[col], lower_bound[col], df[col])

print("Outliers handled successfully.")

"""**Visualize Outliers**"""

# Define a list of unique colors for each feature
colors = ['lightblue', 'lightcoral', 'lightgreen', 'lavender']

# Plotting boxplots after handling outliers with different colors
def plot_boxplots_after(df):
    fig, axs = plt.subplots(2, 2, figsize=(12, 10))
    axs = axs.flatten()

    # Loop through each column and plot the boxplot with different colors
    for i, (col, color) in enumerate(zip(df.columns, colors)):
        sns.boxplot(x=df[col], ax=axs[i], color=color)
        axs[i].set_title(f'After Handling Outliers: {col}')

    plt.tight_layout()
    plt.show()

# Visualize the boxplots after handling outliers with different colors
plot_boxplots_after(df)

""" **Step 6: Feature Engineering**"""

# from sklearn.preprocessing import PolynomialFeatures

# # Apply Polynomial Features (degree 2) to 'TV', 'Radio', and 'Newspaper' columns
# poly = PolynomialFeatures(degree=2)
# poly_features = poly.fit_transform(df[['TV', 'Radio', 'Newspaper']])

# # Create a new DataFrame with the polynomial features
# df_poly = pd.DataFrame(poly_features, columns=poly.get_feature_names_out(['TV', 'Radio', 'Newspaper']))

# # Display the new DataFrame with polynomial features
# print(df_poly.head())

df['TV_Radio_interaction'] = df['TV'] * df['Radio']

"""**Step 7: Feature Scaling**"""

# # Step 1: Create Polynomial Features
# poly = PolynomialFeatures(degree=2)  # You can adjust the degree for more complexity
# poly_features = poly.fit_transform(df[['TV', 'Radio', 'Newspaper']])

# # Step 2: Create a DataFrame for the Polynomial Features
# df_poly = pd.DataFrame(poly_features, columns=poly.get_feature_names_out(['TV', 'Radio', 'Newspaper']))

# # Step 3: Concatenate Polynomial Features with the Original DataFrame
# df = pd.concat([df, df_poly], axis=1)

# # Step 4: Scale the Features
# scaler = StandardScaler()
# df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns)

# # View the scaled DataFrame
# print(df)
#  Step 4: Scale the Features
scaler = StandardScaler()
df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns)

# View the scaled DataFrame
print(df)

"""**Step 8: Feature Selection**"""

# Select the features (independent variables) and target variable (dependent variable)
X = df.drop('Sales', axis=1)  # Assuming 'Sales' is your target
y = df['Sales']

"""**Step 8: Train-Test Split**"""

# Train-test split (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
print("Data split into training and testing sets.")

"""**Step 10: Model Building and Training**

**1. Linear Regression (Baseline Model)**
"""

# Initialize the model
lr_model = LinearRegression()

# Train the model
lr_model.fit(X_train, y_train)

# Predict on the test set
y_pred_lr = lr_model.predict(X_test)

# Evaluate the model
from sklearn.metrics import mean_squared_error, r2_score
lr_mse = mean_squared_error(y_test, y_pred_lr)
lr_r2 = r2_score(y_test, y_pred_lr)

print(f'Linear Regression MSE: {lr_mse:.2f}')
print(f'Linear Regression R²: {lr_r2:.2f}')

"""**Visualization**"""

# Plot actual vs predicted car prices
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred_lr, color='blue')
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linewidth=2)
plt.xlabel('Actual Prices')
plt.ylabel('Predicted Prices')
plt.title('Actual vs Predicted Car Prices')
plt.show()

"""**2. Lasso Regression (with Regularization)**"""

# Initialize the model (alpha is the regularization strength)
lasso_model = Lasso(alpha=0.1)

# Train the model
lasso_model.fit(X_train, y_train)

# Predict on the test set
y_pred_lasso = lasso_model.predict(X_test)

# Evaluate the model
lasso_mse = mean_squared_error(y_test, y_pred_lasso)
lasso_r2 = r2_score(y_test, y_pred_lasso)

print(f'Lasso Regression MSE: {lasso_mse:.2f}')
print(f'Lasso Regression R²: {lasso_r2:.2f}')

# Plot actual vs predicted car prices
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred_lr, color='blue')
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linewidth=2)
plt.xlabel('Actual Prices')
plt.ylabel('Predicted Prices')
plt.title('Actual vs Predicted Car Prices')
plt.show()

"""**3. Random Forest Regressor**"""

# Initialize the model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
rf_model.fit(X_train, y_train)

# Predict on the test set
y_pred_rf = rf_model.predict(X_test)

# Evaluate the model
rf_mse = mean_squared_error(y_test, y_pred_rf)
rf_r2 = r2_score(y_test, y_pred_rf)

print(f'Random Forest MSE: {rf_mse:.2f}')
print(f'Random Forest R²: {rf_r2:.2f}')

# Plot actual vs predicted car prices
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred_rf, color='blue')
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linewidth=2)
plt.xlabel('Actual Prices')
plt.ylabel('Predicted Prices')
plt.title('Actual vs Predicted Car Prices')
plt.show()

"""**Step11 : Model Evaluation**"""

# Make predictions with the trained model
y_pred = rf_model.predict(X_test)

# Calculate MSE and R² Score
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# Display the results
print(f'Mean Squared Error: {mse:.2f}')
print(f'R² Score: {r2:.2f}')

"""**Step 12: Cross-Validation**"""

# Cross-validation for Random Forest (for example)
rf_cv = cross_val_score(rf_model, X, y, cv=5, scoring='neg_mean_squared_error')
print(f'Random Forest CV MSE: {np.mean(rf_cv):.2f}')

"""**Step 13: Model Comparison and Final Choice**"""

# Evaluate all models
lr_mse = mean_squared_error(y_test, lr_model.predict(X_test))
lr_r2 = r2_score(y_test, lr_model.predict(X_test))

lasso_mse = mean_squared_error(y_test, lasso_model.predict(X_test))
lasso_r2 = r2_score(y_test, lasso_model.predict(X_test))

rf_mse = mean_squared_error(y_test, rf_model.predict(X_test))
rf_r2 = r2_score(y_test, rf_model.predict(X_test))

# Print the evaluation results
print(f'Linear Regression - MSE: {lr_mse:.2f}, R²: {lr_r2:.2f}')
print(f'Lasso Regression - MSE: {lasso_mse:.2f}, R²: {lasso_r2:.2f}')
print(f'Random Forest - MSE: {rf_mse:.2f}, R²: {rf_r2:.2f}')

"""**Step 14: Model Deployment with Dash**"""

# Initialize Dash app
app = dash.Dash(__name__)

# Layout with input fields for user input
app.layout = html.Div([
    html.H1("Sales Prediction"),

    dcc.Input(id='tv-input', type='number', placeholder="TV Spend ($)", value=100),
    dcc.Input(id='radio-input', type='number', placeholder="Radio Spend ($)", value=100),
    dcc.Input(id='newspaper-input', type='number', placeholder="Newspaper Spend ($)", value=100),

    html.Button('Predict', id='predict-button'),

    html.Div(id='output')
])

# Callback function to predict sales based on user input
@app.callback(
    Output('output', 'children'),
    [Input('tv-input', 'value'),
     Input('radio-input', 'value'),
     Input('newspaper-input', 'value')]
)
def predict_sales(tv, radio, newspaper):
    # Prepare the input features for prediction
    features = np.array([[tv, radio, newspaper]])

    # Predict using the best model (for example, Random Forest)
    predicted_sales = rf_model.predict(features)[0]

    return f'Predicted Sales: ${predicted_sales:.2f}'

# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)